=======================================================
Test on utterance 1:
  Line 0: write a regular expression that
    Top prediction: 
  Line 1: ONLY matches strings
    Top prediction: fb:en.any
    All 2 derivations and their counts: 
      fb:en.any : 3
      repeat(fb:en.any,1,) : 1
  Line 2: NO NUMBERS
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 2
      not(fb:en.num) : 1
  Line 3: NO SPECIAL CHARACTERS
    Top prediction: fb:en.let
    All 6 derivations and their counts: 
      fb:en.sp : 2
      not(fb:en.any) : 1
      fb:en.let : 3
      fb:en.any : 3
      not(fb:en.let) : 1
      not(fb:en.sp) : 1
  Line 4: just letters from A - Z.
    Top prediction: fb:en.let
    All 1 derivations and their counts: 
      fb:en.let : 1
=======================================================
Test on utterance 2:
  Line 0: write regular expression in C# to validate that 
    Top prediction: 
  Line 1: the input does not contain double <M0>
    Top prediction: fb:en.const
    All 4 derivations and their counts: 
      not(fb:en.const) : 1
      not(contain(fb:en.const)) : 1
      fb:en.const : 7
      contain(fb:en.const) : 1
=======================================================
Test on utterance 3:
  Line 0: write regular expression that 
    Top prediction: 
  Line 1: allows only digits
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 3
      repeat(fb:en.num,1,) : 1
  Line 2: characters like <M0> <M1> <M2> <M3> <M4> and <M5>.
    Top prediction: fb:en.let
    All 4 derivations and their counts: 
      and(fb:en.const,fb:en.const) : 1
      fb:en.let : 1
      fb:en.any : 1
      fb:en.const : 6
=======================================================
Test on utterance 4:
  Line 0: validate a textbox with decimal number. 
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
  Line 1: First two digit and decimal point and followed by a single digit. 
    Top prediction: repeat(fb:en.num,1)
    All 24 derivations and their counts: 
      repeat(and(fb:en.num,fb:en.num),1) : 1
      fb:en.num : 2
      repeat(and(fb:en.num,fb:en.dp),1,2) : 1
      repeat(fb:en.num,1) : 2
      and(fb:en.num,fb:en.num) : 1
      repeat(and(repeat(fb:en.num,2),fb:en.dp),1) : 1
      fb:en.dp : 1
      and(repeat(repeat(fb:en.num,2),1),fb:en.dp) : 1
      and(repeat(fb:en.num,1),fb:en.num) : 1
      repeat(repeat(fb:en.num,2),1) : 2
      repeat(fb:en.num,1,2) : 2
      repeat(and(repeat(fb:en.num,2),fb:en.num),1) : 1
      repeat(repeat(and(fb:en.num,fb:en.num),2),1) : 1
      and(fb:en.num,fb:en.dp) : 1
      repeat(fb:en.dp,1,2) : 1
      and(repeat(fb:en.num,1),fb:en.dp) : 1
      and(repeat(repeat(fb:en.num,2),1),fb:en.num) : 1
      repeat(fb:en.dp,1) : 1
      and(repeat(fb:en.num,1,2),fb:en.dp) : 1
      repeat(repeat(and(fb:en.num,fb:en.dp),2),1) : 1
      repeat(and(fb:en.num,fb:en.dp),1) : 1
      repeat(and(fb:en.num,fb:en.num),1,2) : 1
      and(repeat(fb:en.num,1,2),fb:en.num) : 1
      repeat(repeat(fb:en.dp,2),1) : 1
  Line 2: i need the exact digit like this two digit.single digit.
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 2
  Line 3: The final single digit is <M0> only.
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.const : 1
=======================================================
Test on utterance 5:
  Line 0: What is the regular expression for validating a month with the leading zero?
    Top prediction: 
=======================================================
Test on utterance 6:
  Line 0: The input will be in the form a <M0> separated tuple of three values. 
    Top prediction: sep(fb:en.const)
    All 2 derivations and their counts: 
      sep(fb:en.const) : 1
      fb:en.const : 1
  Line 1: The first value will be an integer (potentially a long in terms of size/length)
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 2: with the other two values being either numeric or a string
    Top prediction: or(fb:en.num,fb:en.any)
    All 10 derivations and their counts: 
      repeat(fb:en.any,2) : 1
      fb:en.num : 1
      or(repeat(fb:en.num,2),fb:en.any) : 1
      contain(fb:en.any) : 1
      or(contain(fb:en.num),fb:en.any) : 1
      or(fb:en.num,fb:en.any) : 8
      fb:en.any : 11
      repeat(or(fb:en.num,fb:en.any),2) : 1
      contain(fb:en.num) : 1
      contain(or(fb:en.num,fb:en.any)) : 1
=======================================================
Test on utterance 7:
  Line 0: Need to validate the following string using regular expression:
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 1: Key = Value ; Key = Value ; Key = Value and so on. 
    Top prediction: 
  Line 2: Key and value can contain anything except <M0> and <M1>
    Top prediction: fb:en.const
    All 8 derivations and their counts: 
      and(contain(fb:en.const),fb:en.const) : 1
      not(and(fb:en.const,fb:en.const)) : 1
      not(fb:en.const) : 1
      and(fb:en.const,fb:en.const) : 8
      contain(and(fb:en.const,fb:en.const)) : 1
      and(not(fb:en.const),fb:en.const) : 1
      fb:en.const : 11
      contain(fb:en.const) : 1
  Line 3: Key and Value both cannot be blank or empty with <M2>
    Top prediction: fb:en.const
    All 3 derivations and their counts: 
      not(fb:en.const) : 1
      fb:en.const : 12
      contain(fb:en.const) : 1
  Line 4: Input string does not ends with <M3>
    Top prediction: fb:en.const
    All 8 derivations and their counts: 
      not(endwith(fb:en.const)) : 2
      not(fb:en.const) : 1
      endwith(fb:en.const) : 2
      fb:en.const : 7
      fb:en.any : 1
      not(endwith(contain(fb:en.const))) : 1
      endwith(contain(fb:en.const)) : 1
      contain(fb:en.const) : 1
=======================================================
Test on utterance 8:
  Line 0: It should accept numbers only with decimal part <M0> or <M1> only.
    Top prediction: fb:en.num
    All 4 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
      fb:en.const : 2
      or(fb:en.const,fb:en.const) : 1
=======================================================
Test on utterance 9:
  Line 0: I want this value to accept up to 18 digits before the decimal,
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
      followedby(fb:en.num,fb:en.dp) : 1
  Line 1: and 1 digit after. 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 2: With the decimal point and the digit after it being optional
    Top prediction: contain(fb:en.dp)
    All 7 derivations and their counts: 
      fb:en.num : 1
      followedby(fb:en.dp,fb:en.num) : 1
      contain(fb:en.dp) : 1
      fb:en.dp : 1
      followedby(contain(fb:en.dp),fb:en.num) : 1
      contain(fb:en.num) : 1
      contain(followedby(fb:en.dp,fb:en.num)) : 1
=======================================================
Test on utterance 10:
  Line 0: The value should not contain only <M0> and if there is a <M1> the length should be more than 3 characters including <M2>. 
    Top prediction: fb:en.const
    All 6 derivations and their counts: 
      and(fb:en.const,fb:en.let) : 1
      and(fb:en.const,fb:en.const) : 2
      and(fb:en.const,fb:en.any) : 1
      fb:en.let : 1
      fb:en.const : 3
      fb:en.any : 1
  Line 1: <M3> can be anywhere in the string (dot is included).
    Top prediction: fb:en.const
    All 3 derivations and their counts: 
      fb:en.dp : 1
      fb:en.const : 1
      fb:en.any : 1
=======================================================
Test on utterance 11:
  Line 0: I want to develop one regular expression which 
    Top prediction: 
  Line 1: validates only strings which 
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 2: have " <M0> , <M1> or <M2> "
    Top prediction: contain(fb:en.const)
    All 5 derivations and their counts: 
      contain(or(fb:en.const,fb:en.const)) : 1
      or(contain(fb:en.const),fb:en.const) : 1
      fb:en.const : 3
      contain(fb:en.const) : 3
      or(fb:en.const,fb:en.const) : 1
=======================================================
Test on utterance 12:
  Line 0: optional number of digits followed by an ' <M0> ' and an optional (' <M1> ' followed by one or more digits)
    Top prediction: fb:en.num
    All 10 derivations and their counts: 
      optional(fb:en.num) : 3
      optional(followedby(fb:en.num,fb:en.num)) : 2
      fb:en.num : 3
      followedby(optional(fb:en.num),fb:en.num) : 2
      optional(fb:en.const) : 2
      optional(followedby(fb:en.num,fb:en.const)) : 2
      followedby(optional(fb:en.num),fb:en.const) : 2
      followedby(fb:en.num,fb:en.num) : 2
      fb:en.const : 2
      followedby(fb:en.num,fb:en.const) : 2
=======================================================
Test on utterance 13:
  Line 0: I wan`t to validate next formats:
    Top prediction: 
  Line 1: Decimal numbers with max 3 decimal places
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 2
  Line 2: Exclude <M0>
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 2
=======================================================
Test on utterance 14:
  Line 0: write a Regular Expression validator to accept numbers only with decimal part <M0> or <M1> only and in range 0-5. 
    Top prediction: fb:en.num
    All 4 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
      fb:en.const : 2
      or(fb:en.const,fb:en.const) : 1
  Line 1: No matter how many 0 in front or behind the numbers it can be valid.
    Top prediction: not(fb:en.num)
    All 2 derivations and their counts: 
      fb:en.num : 1
      not(fb:en.num) : 1
=======================================================
Test on utterance 15:
  Line 0: i need a Regular that validate Decimal (18,3) 
    Top prediction: fb:en.dp
    All 1 derivations and their counts: 
      fb:en.dp : 1
  Line 1: this mean max number of digits before <M0> is 15 and accept 3 numbers after <M1> . 
    Top prediction: fb:en.num
    All 10 derivations and their counts: 
      fb:en.num : 3
      followedby(followedby(fb:en.num,fb:en.num),fb:en.num) : 1
      followedby(fb:en.num,followedby(fb:en.num,fb:en.num)) : 1
      followedby(followedby(fb:en.num,fb:en.const),fb:en.num) : 1
      followedby(fb:en.num,followedby(fb:en.const,fb:en.num)) : 3
      followedby(fb:en.const,followedby(fb:en.num,fb:en.num)) : 1
      followedby(fb:en.num,fb:en.num) : 4
      fb:en.const : 2
      followedby(fb:en.const,fb:en.num) : 2
      followedby(fb:en.num,fb:en.const) : 2
  Line 2: 18 precision 3 scale .
    Top prediction: 
=======================================================
Test on utterance 16:
  Line 0: I need to create a regular expression for a string in the format <whole-number> @ <whole-numbers> % 
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 1: only single numeric digit should be allowed before <M0>
    Top prediction: fb:en.const
    All 4 derivations and their counts: 
      fb:en.num : 3
      repeat(fb:en.const,1,) : 1
      repeat(fb:en.num,1,) : 3
      fb:en.const : 9
  Line 2: only <M1> special character after the numeric digit
    Top prediction: followedby(fb:en.num,fb:en.sp)
    All 29 derivations and their counts: 
      repeat(fb:en.let,1,) : 1
      followedby(fb:en.const,fb:en.let) : 1
      followedby(fb:en.const,fb:en.sp) : 1
      repeat(fb:en.sp,1,) : 1
      followedby(fb:en.num,fb:en.num) : 1
      fb:en.let : 1
      followedby(fb:en.num,repeat(fb:en.any,1,)) : 3
      fb:en.sp : 1
      repeat(fb:en.const,1,) : 1
      followedby(fb:en.const,fb:en.any) : 1
      repeat(followedby(fb:en.const,fb:en.any),1,) : 1
      followedby(repeat(fb:en.const,1,),fb:en.sp) : 1
      repeat(followedby(fb:en.num,fb:en.any),1,) : 3
      repeat(fb:en.any,1,) : 1
      repeat(followedby(fb:en.num,fb:en.let),1,) : 3
      fb:en.num : 16
      followedby(fb:en.num,repeat(fb:en.sp,1,)) : 3
      repeat(followedby(fb:en.const,fb:en.let),1,) : 1
      repeat(followedby(fb:en.num,fb:en.sp),1,) : 3
      repeat(followedby(fb:en.const,fb:en.sp),1,) : 1
      followedby(fb:en.num,repeat(fb:en.let,1,)) : 3
      followedby(fb:en.num,fb:en.sp) : 7
      followedby(fb:en.num,fb:en.let) : 9
      followedby(repeat(fb:en.const,1,),fb:en.any) : 1
      repeat(fb:en.num,1,) : 3
      fb:en.const : 1
      fb:en.any : 1
      followedby(fb:en.num,fb:en.any) : 9
      followedby(repeat(fb:en.const,1,),fb:en.let) : 1
  Line 3: there should be only 3 or less numeric digits after the <M2>
    Top prediction: followedby(fb:en.const,fb:en.num)
    All 14 derivations and their counts: 
      repeat(followedby(fb:en.const,fb:en.num),1,) : 2
      fb:en.num : 3
      repeat(fb:en.const,3) : 2
      repeat(repeat(followedby(fb:en.const,fb:en.num),3),1,) : 2
      followedby(fb:en.num,fb:en.num) : 1
      repeat(repeat(fb:en.const,3),1,) : 1
      followedby(fb:en.const,repeat(fb:en.num,3)) : 4
      followedby(fb:en.const,repeat(repeat(fb:en.num,3),1,)) : 2
      repeat(fb:en.const,1,) : 1
      repeat(followedby(fb:en.const,repeat(fb:en.num,3)),1,) : 2
      repeat(followedby(fb:en.const,fb:en.num),3) : 4
      fb:en.const : 12
      followedby(fb:en.const,fb:en.num) : 17
      followedby(fb:en.const,repeat(fb:en.num,1,)) : 2
  Line 4: only <M3> special character should be allowed at the end of the string.
    Top prediction: fb:en.const
    All 8 derivations and their counts: 
      repeat(fb:en.let,1,) : 1
      fb:en.sp : 1
      repeat(fb:en.const,1,) : 1
      repeat(fb:en.sp,1,) : 1
      fb:en.let : 1
      fb:en.const : 1
      fb:en.any : 2
      repeat(fb:en.any,1,) : 2
=======================================================
Test on utterance 17:
  Line 0: I want to validate a 10 digit USA style phone number using a Regular Expression in Javascript. 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 2
  Line 1: It should allow (validate as correct) the following formats:
    Top prediction: 
  Line 2: xxx - xxx - xxxx
    Top prediction: 
=======================================================
Test on utterance 18:
  Line 0: accept numeric values that 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 1: are seven or ten digits
    Top prediction: repeat(fb:en.num,7)
    All 3 derivations and their counts: 
      fb:en.num : 5
      repeat(fb:en.num,10) : 1
      repeat(fb:en.num,7) : 1
=======================================================
Test on utterance 19:
  Line 0: I am trying to write a regular expression which 
    Top prediction: 
  Line 1: validates a text box to have only digits with length 5 or 9.
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
=======================================================
Test on utterance 20:
  Line 0: How can i write valid regular expression for Oracle's Number(2,2)
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 1: Also digits after decimal should be either,
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      followedby(fb:en.dp,fb:en.num) : 1
      fb:en.dp : 1
  Line 2: 1 or 2 but not more than 2,
    Top prediction: or(1,2)
    All 1 derivations and their counts: 
      or(1,2) : 1
  Line 3: also it can be optional. 
    Top prediction: 
  Line 4: The numer should never start with <M0> but can start with <M1>.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 2
=======================================================
Test on utterance 21:
  Line 0: I need a regular expression that 
    Top prediction: 
  Line 1: validates a number, 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 2: but doesn't require a digit after the decimal
    Top prediction: followedby(fb:en.dp,fb:en.num)
    All 6 derivations and their counts: 
      fb:en.num : 1
      followedby(fb:en.dp,fb:en.num) : 6
      fb:en.dp : 9
      not(followedby(fb:en.dp,fb:en.num)) : 1
      not(fb:en.dp) : 1
      followedby(fb:en.dp,not(fb:en.num)) : 1
=======================================================
Test on utterance 22:
  Line 0: I'm trying to write a regular expression to check whether or not 
    Top prediction: 
  Line 1: a proposed name is valid in a gaming platform.
    Top prediction: 
  Line 2: Name must contain at least 3 and no more than 20 letters
    Top prediction: fb:en.let
    All 7 derivations and their counts: 
      repeat(fb:en.let,3,) : 1
      repeat(fb:en.let,3) : 1
      fb:en.let : 12
      contain(repeat(fb:en.let,3,)) : 1
      contain(fb:en.let) : 1
      not(fb:en.let) : 1
      repeat(fb:en.let,20) : 1
  Line 3: Name must start with a uppercase letter
    Top prediction: fb:en.let
    All 5 derivations and their counts: 
      startwith(fb:en.let) : 1
      fb:en.cap : 1
      startwith(contain(fb:en.let)) : 1
      fb:en.let : 7
      contain(fb:en.let) : 1
  Line 4: Name must never have two uppercase letters in a row
    Top prediction: fb:en.cap
    All 2 derivations and their counts: 
      fb:en.cap : 1
      fb:en.let : 1
  Line 5: <M0> are allowed, 
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 6: but must be preceded by a letter and be followed by an uppercase letter
    Top prediction: and(fb:en.let,fb:en.let)
    All 7 derivations and their counts: 
      followedby(and(fb:en.let,fb:en.cap),fb:en.let) : 1
      and(fb:en.let,fb:en.cap) : 1
      and(fb:en.let,fb:en.let) : 7
      fb:en.cap : 1
      followedby(fb:en.cap,fb:en.let) : 2
      fb:en.let : 15
      followedby(fb:en.let,fb:en.let) : 1
  Line 7: <M1> are allowed, 
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 8: but must be preceded by a letter and be followed by a lowercase letter
    Top prediction: and(fb:en.let,fb:en.let)
    All 7 derivations and their counts: 
      fb:en.low : 1
      and(fb:en.let,fb:en.let) : 7
      followedby(fb:en.low,fb:en.let) : 2
      fb:en.let : 15
      followedby(fb:en.let,fb:en.let) : 1
      followedby(and(fb:en.let,fb:en.low),fb:en.let) : 1
      and(fb:en.let,fb:en.low) : 1
  Line 9: All uppercase letters must be followed by a lowercase letter unless they are followed by a <M2> or <M3>
    Top prediction: fb:en.const
    All 12 derivations and their counts: 
      fb:en.low : 1
      fb:en.cap : 1
      or(followedby(fb:en.let,fb:en.const),fb:en.const) : 1
      fb:en.let : 2
      followedby(fb:en.let,or(fb:en.const,fb:en.const)) : 1
      or(followedby(fb:en.low,fb:en.const),fb:en.const) : 1
      fb:en.const : 20
      followedby(fb:en.low,fb:en.const) : 1
      followedby(fb:en.let,fb:en.const) : 1
      followedby(fb:en.const,fb:en.const) : 2
      or(fb:en.const,fb:en.const) : 17
      followedby(fb:en.low,or(fb:en.const,fb:en.const)) : 1
=======================================================
Test on utterance 23:
  Line 0: I need a regular expression that 
    Top prediction: 
  Line 1: can validate an input string to make sure it is a number between 1-30 and up to 2 decimal places.
    Top prediction: fb:en.any
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
      fb:en.any : 1
=======================================================
Test on utterance 24:
  Line 0: I need to validate each sub string length is 3 which
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 1: is split by <M0>.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 25:
  Line 0: I need a regular expression that 
    Top prediction: 
  Line 1: can validate that 
    Top prediction: 
  Line 2: a string is an alphanumeric <M0> delimited string.
    Top prediction: fb:en.any
    All 4 derivations and their counts: 
      sep(fb:en.const) : 1
      fb:en.letnum : 1
      fb:en.any : 2
      fb:en.const : 1
=======================================================
Test on utterance 26:
  Line 0: I need their cell phone formats to be like this  04AB - XXXXXXX Where 
    Top prediction: 
  Line 1: A can be either <M0> or <M1> and 
    Top prediction: fb:en.const
    All 2 derivations and their counts: 
      fb:en.const : 2
      or(fb:en.const,fb:en.const) : 1
  Line 2: B can be either <M2>, <M3> or <M4> 
    Top prediction: fb:en.const
    All 2 derivations and their counts: 
      fb:en.const : 11
      or(fb:en.const,fb:en.const) : 7
  Line 3: X can be from <M5>
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 5
  Line 4: There must be exactly 7 numbers (X) after 04AB 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 5: It must always start with <M6>
    Top prediction: fb:en.const
    All 4 derivations and their counts: 
      startwith(fb:en.const) : 1
      fb:en.const : 6
      startwith(contain(fb:en.const)) : 1
      contain(fb:en.const) : 1
=======================================================
Test on utterance 27:
  Line 0: How should I write my regular expressions code to match following criteria? 
    Top prediction: 
  Line 1: It consists of at least two <M0> separated names 
    Top prediction: repeat(sep(fb:en.const),2,)
    All 4 derivations and their counts: 
      repeat(sep(fb:en.const),2) : 1
      sep(fb:en.const) : 1
      repeat(sep(fb:en.const),2,) : 1
      fb:en.const : 1
  Line 2: All <M1> separated names at least 2 characters long 
    Top prediction: sep(fb:en.const)
    All 4 derivations and their counts: 
      sep(fb:en.const) : 1
      fb:en.let : 1
      fb:en.const : 1
      fb:en.any : 1
  Line 3: At least one <M2> separated name is at least 4 characters long
    Top prediction: fb:en.const
    All 6 derivations and their counts: 
      repeat(fb:en.let,1,) : 1
      repeat(fb:en.const,1,) : 1
      fb:en.let : 1
      fb:en.const : 1
      fb:en.any : 1
      repeat(fb:en.any,1,) : 1
=======================================================
Test on utterance 28:
  Line 0: I need to write a regular expression to verify if a file input follows a rule:
    Top prediction: 
  Line 1: A111B2_3_C.exe in which:
    Top prediction: 
  Line 2: A:
    Top prediction: 
  Line 3: compulsory,
    Top prediction: 
  Line 4: it must be a ' <M0> '
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 5: 111:
    Top prediction: 
  Line 6: compulsory, 
    Top prediction: 
  Line 7: it is a natural number
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 5
  Line 8: B:
    Top prediction: 
  Line 9: compulsory, 
    Top prediction: 
  Line 10: it must be a ' <M1> '
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 11: 2:
    Top prediction: 
  Line 12: compulsory, 
    Top prediction: 
  Line 13: it is in range from 1 -> 6
    Top prediction: 
  Line 14: _:
    Top prediction: 
  Line 15: compulsory, 
    Top prediction: 
  Line 16: it must be ' <M2> '
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 17: 3:
    Top prediction: 
  Line 18: compulsory, 
    Top prediction: 
  Line 19: it must be a nature number
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 6
  Line 20: _:
    Top prediction: 
  Line 21: optional if C followed, 
    Top prediction: 
  Line 22: it must be ' <M3> '
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 23: C:
    Top prediction: 
  Line 24: optional, 
    Top prediction: 
  Line 25: C is a natural number
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 5
  Line 26: .exe:
    Top prediction: 
  Line 27: is the end extension of the file
    Top prediction: 
=======================================================
Test on utterance 29:
  Line 0: Can anyone please help me to find the suitable regular expression to validate a string that
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 1: has <M0> separated numbers
    Top prediction: fb:en.num
    All 4 derivations and their counts: 
      fb:en.num : 4
      fb:en.const : 1
      contain(fb:en.num) : 1
      contain(fb:en.const) : 1
=======================================================
Test on utterance 30:
  Line 0: I'm looking for the perfect regular expression for validation a german car license the number has too look like this:
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 1: 1 - 3 Letters
    Top prediction: fb:en.let
    All 3 derivations and their counts: 
      repeat(fb:en.let,1) : 1
      repeat(fb:en.let,3) : 1
      fb:en.let : 4
  Line 2: a <M0> (i know the minus is now out of date, 
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 3: but the customer want it that
    Top prediction: 
  Line 4: way)
    Top prediction: 
  Line 5: 1 - 2 Letters
    Top prediction: fb:en.let
    All 3 derivations and their counts: 
      repeat(fb:en.let,2) : 1
      repeat(fb:en.let,1) : 1
      fb:en.let : 4
  Line 6: a <M1>
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 2
  Line 7: 1 - 4 numbers
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 4
      repeat(fb:en.num,1) : 1
      repeat(fb:en.num,4) : 1
=======================================================
Test on utterance 31:
  Line 0: I want to validate if my input consists starting with 8 hexadecimal characters followed by a <M0>
    Top prediction: followedby(fb:en.let,fb:en.const)
    All 43 derivations and their counts: 
      followedby(startwith(fb:en.let),fb:en.const) : 1
      startwith(fb:en.const) : 1
      contain(repeat(fb:en.const,8)) : 1
      startwith(followedby(fb:en.let,fb:en.const)) : 1
      contain(followedby(fb:en.let,fb:en.const)) : 1
      contain(followedby(fb:en.any,fb:en.const)) : 1
      startwith(contain(followedby(repeat(fb:en.any,8),fb:en.const))) : 1
      followedby(repeat(fb:en.any,8),fb:en.const) : 1
      followedby(startwith(fb:en.any),fb:en.const) : 1
      fb:en.let : 1
      startwith(contain(followedby(fb:en.any,fb:en.const))) : 1
      repeat(followedby(fb:en.any,fb:en.const),8) : 1
      startwith(contain(followedby(fb:en.let,fb:en.const))) : 1
      contain(repeat(followedby(fb:en.any,fb:en.const),8)) : 1
      startwith(contain(repeat(followedby(fb:en.let,fb:en.const),8))) : 1
      followedby(startwith(contain(fb:en.any)),fb:en.const) : 1
      startwith(contain(repeat(followedby(fb:en.any,fb:en.const),8))) : 1
      startwith(followedby(contain(fb:en.any),fb:en.const)) : 1
      followedby(fb:en.any,fb:en.const) : 13
      contain(repeat(followedby(fb:en.let,fb:en.const),8)) : 1
      startwith(contain(repeat(fb:en.const,8))) : 1
      contain(fb:en.const) : 1
      followedby(contain(repeat(fb:en.any,8)),fb:en.const) : 1
      startwith(contain(followedby(repeat(fb:en.let,8),fb:en.const))) : 1
      startwith(followedby(contain(fb:en.let),fb:en.const)) : 1
      contain(followedby(repeat(fb:en.let,8),fb:en.const)) : 1
      startwith(followedby(contain(repeat(fb:en.let,8)),fb:en.const)) : 1
      startwith(followedby(fb:en.any,fb:en.const)) : 1
      followedby(contain(repeat(fb:en.let,8)),fb:en.const) : 1
      followedby(startwith(contain(fb:en.let)),fb:en.const) : 1
      startwith(followedby(contain(repeat(fb:en.any,8)),fb:en.const)) : 1
      followedby(contain(fb:en.let),fb:en.const) : 1
      followedby(repeat(fb:en.let,8),fb:en.const) : 1
      followedby(startwith(contain(repeat(fb:en.let,8))),fb:en.const) : 1
      followedby(contain(fb:en.any),fb:en.const) : 1
      followedby(startwith(contain(repeat(fb:en.any,8))),fb:en.const) : 1
      fb:en.const : 17
      startwith(contain(fb:en.const)) : 1
      fb:en.any : 1
      followedby(fb:en.let,fb:en.const) : 13
      contain(followedby(repeat(fb:en.any,8),fb:en.const)) : 1
      repeat(followedby(fb:en.let,fb:en.const),8) : 1
      repeat(fb:en.const,8) : 1
  Line 1: followed by any number of charters with any value.
    Top prediction: fb:en.any
    All 5 derivations and their counts: 
      fb:en.num : 1
      fb:en.any : 2
      followedby(fb:en.any,fb:en.any) : 1
      followedby(fb:en.num,fb:en.any) : 1
      followedby(fb:en.any,fb:en.num) : 1
=======================================================
Test on utterance 32:
  Line 0: I'm trying to devise a regular expression which
    Top prediction: 
  Line 1: will accept decimal number up to 4 digits.
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.num : 2
      fb:en.dp : 1
=======================================================
Test on utterance 33:
  Line 0: Need a regular expression to check a string with 4 digit and the <M0> in trail.
    Top prediction: fb:en.any
    All 4 derivations and their counts: 
      fb:en.num : 1
      fb:en.any : 1
      fb:en.const : 1
      and(fb:en.num,fb:en.const) : 1
=======================================================
Test on utterance 34:
  Line 0: I need a regular expression in .net which
    Top prediction: 
  Line 1: will only allow a maximum of two digits after " <M0> "
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.const : 1
      followedby(fb:en.const,fb:en.num) : 1
  Line 2: will only allow a maximum of two digits before " <M1> "
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.const : 1
      followedby(fb:en.num,fb:en.const) : 1
  Line 3: has a maximum length of 5
    Top prediction: 
  Line 4: represents a number greater than 0
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 5: represents a number not greater than 100
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 1
      not(fb:en.num) : 1
  Line 6: has a number not greater than 11 after " <M2> "
    Top prediction: contain(fb:en.num)
    All 7 derivations and their counts: 
      fb:en.num : 1
      contain(not(fb:en.num)) : 1
      not(contain(fb:en.num)) : 1
      not(fb:en.num) : 1
      fb:en.const : 1
      contain(fb:en.num) : 1
      contain(fb:en.const) : 1
=======================================================
Test on utterance 35:
  Line 0: Valid input are at least two characters with <M0> symbol. 
    Top prediction: fb:en.let
    All 3 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
      fb:en.const : 1
  Line 1: In other words valid format is < ' <M1> ' or nothing> <at least two characters> < ' <M2> ' or nothing>
    Top prediction: fb:en.any
    All 2 derivations and their counts: 
      fb:en.any : 1
      fb:en.const : 2
=======================================================
Test on utterance 36:
  Line 0: I'm trying to validate a value and that
    Top prediction: 
  Line 1: value cannot have a zero and then a number in front of it
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
=======================================================
Test on utterance 37:
  Line 0: I am trying to create a regular expression which 
    Top prediction: 
  Line 1: will validate a text. 
    Top prediction: 
  Line 2: Conditions are as follows:
    Top prediction: 
  Line 3: Must contain at least one alphanumeric character [A-Z a-z 0-9]
    Top prediction: fb:en.letnum
    All 3 derivations and their counts: 
      fb:en.letnum : 1
      fb:en.let : 1
      fb:en.any : 1
  Line 4: Can contain allowed special character like [ <M0> <M1> ].
    Top prediction: fb:en.sp
    All 4 derivations and their counts: 
      fb:en.sp : 1
      fb:en.let : 1
      fb:en.any : 1
      fb:en.const : 2
  Line 5: This is optional.
    Top prediction: 
  Line 6: No other characters are allowed other than the above mentioned chars[includes <M2> and <M3>].
    Top prediction: not(fb:en.let)
    All 9 derivations and their counts: 
      not(and(fb:en.const,fb:en.const)) : 1
      not(fb:en.const) : 2
      and(not(fb:en.const),fb:en.const) : 1
      and(fb:en.const,fb:en.const) : 1
      not(fb:en.any) : 1
      fb:en.let : 1
      fb:en.any : 1
      fb:en.const : 2
      not(fb:en.let) : 1
  Line 7: Text length should be less than 8.
    Top prediction: 
=======================================================
Test on utterance 38:
  Line 0: I need a regular expression that 
    Top prediction: 
  Line 1: will test the input
    Top prediction: 
  Line 2: Should start with only one <M0> symbol or optional ( + should not come in between )
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 3: should not contain alphabets and any other special character
    Top prediction: not(contain(and(fb:en.let,fb:en.sp)))
    All 36 derivations and their counts: 
      and(not(contain(fb:en.let)),fb:en.sp) : 1
      and(not(fb:en.let),fb:en.any) : 1
      contain(fb:en.any) : 1
      contain(fb:en.sp) : 1
      not(contain(fb:en.any)) : 1
      not(fb:en.any) : 1
      fb:en.let : 10
      and(fb:en.let,fb:en.sp) : 4
      fb:en.sp : 8
      and(not(fb:en.let),fb:en.sp) : 1
      and(not(fb:en.let),fb:en.let) : 1
      and(fb:en.let,fb:en.any) : 5
      and(contain(fb:en.let),fb:en.sp) : 1
      not(and(fb:en.let,fb:en.sp)) : 1
      not(fb:en.let) : 1
      not(fb:en.sp) : 1
      contain(and(fb:en.let,fb:en.sp)) : 1
      not(contain(fb:en.let)) : 1
      not(and(contain(fb:en.let),fb:en.let)) : 1
      and(not(contain(fb:en.let)),fb:en.any) : 1
      and(fb:en.let,fb:en.let) : 4
      contain(and(fb:en.let,fb:en.any)) : 1
      not(and(contain(fb:en.let),fb:en.sp)) : 1
      contain(fb:en.let) : 1
      not(and(fb:en.let,fb:en.any)) : 1
      not(contain(and(fb:en.let,fb:en.sp))) : 1
      not(contain(and(fb:en.let,fb:en.let))) : 1
      not(contain(fb:en.sp)) : 1
      and(not(contain(fb:en.let)),fb:en.let) : 1
      not(contain(and(fb:en.let,fb:en.any))) : 1
      contain(and(fb:en.let,fb:en.let)) : 1
      and(contain(fb:en.let),fb:en.let) : 1
      not(and(contain(fb:en.let),fb:en.any)) : 1
      not(and(fb:en.let,fb:en.let)) : 1
      fb:en.any : 10
      and(contain(fb:en.let),fb:en.any) : 1
  Line 4: Should not contain consecutive <M1> symbols
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 39:
  Line 0: I am trying to use a regular expression to validate decimal values .
    Top prediction: fb:en.dp
    All 1 derivations and their counts: 
      fb:en.dp : 1
  Line 1: Rules :
    Top prediction: 
  Line 2: It should allow positive numbers.
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 3: It should allow max 13 numbers before decimal point
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
      followedby(fb:en.num,fb:en.dp) : 1
  Line 4: It should allow max two number after decimal.
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      followedby(fb:en.dp,fb:en.num) : 1
      fb:en.dp : 1
  Line 5: It should allow . ( dot ) with number like a <M0>
    Top prediction: fb:en.const
    All 4 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
      fb:en.const : 12
      contain(fb:en.const) : 1
  Line 6: It should not allow the <M1>
    Top prediction: fb:en.const
    All 2 derivations and their counts: 
      not(fb:en.const) : 1
      fb:en.const : 6
=======================================================
Test on utterance 40:
  Line 0: i need regular expression for :
    Top prediction: 
  Line 1: one or two digits then <M0> and one or two digits.
    Top prediction: or(1,2)
    All 42 derivations and their counts: 
      and(repeat(fb:en.const,1),repeat(fb:en.num,1)) : 1
      repeat(fb:en.num,1) : 2
      repeat(fb:en.const,1) : 1
      followedby(repeat(fb:en.num,1),and(fb:en.const,fb:en.num)) : 1
      followedby(fb:en.num,fb:en.num) : 1
      repeat(followedby(fb:en.num,and(fb:en.const,or(1,2))),1) : 1
      repeat(followedby(fb:en.num,and(fb:en.const,fb:en.num)),1) : 1
      or(1,2) : 1
      repeat(followedby(fb:en.num,fb:en.const),1) : 1
      and(followedby(repeat(fb:en.num,1),fb:en.const),fb:en.num) : 1
      followedby(fb:en.num,and(fb:en.const,fb:en.num)) : 1
      and(repeat(followedby(fb:en.num,fb:en.const),1),or(1,2)) : 1
      and(repeat(fb:en.const,1),fb:en.num) : 1
      and(followedby(fb:en.num,fb:en.const),repeat(fb:en.num,1)) : 1
      and(repeat(followedby(fb:en.num,fb:en.const),1),repeat(fb:en.num,1)) : 1
      and(repeat(fb:en.const,1),or(1,2)) : 1
      and(fb:en.const,or(1,2)) : 1
      fb:en.num : 2
      followedby(fb:en.num,and(fb:en.const,or(1,2))) : 1
      followedby(repeat(fb:en.num,1),fb:en.num) : 1
      followedby(repeat(fb:en.num,1),fb:en.const) : 1
      and(followedby(fb:en.num,fb:en.const),or(1,2)) : 1
      repeat(followedby(fb:en.num,and(fb:en.const,repeat(fb:en.num,1))),1) : 1
      followedby(repeat(fb:en.num,1),and(fb:en.const,repeat(fb:en.num,1))) : 1
      followedby(or(1,2),fb:en.num) : 1
      and(repeat(followedby(fb:en.num,fb:en.const),1),fb:en.num) : 1
      repeat(and(fb:en.const,repeat(fb:en.num,1)),1) : 1
      repeat(and(followedby(fb:en.num,fb:en.const),repeat(fb:en.num,1)),1) : 1
      and(followedby(fb:en.num,fb:en.const),fb:en.num) : 1
      followedby(repeat(fb:en.num,1),and(fb:en.const,or(1,2))) : 1
      and(followedby(repeat(fb:en.num,1),fb:en.const),or(1,2)) : 1
      and(fb:en.const,fb:en.num) : 1
      followedby(fb:en.num,and(fb:en.const,repeat(fb:en.num,1))) : 1
      and(followedby(repeat(fb:en.num,1),fb:en.const),repeat(fb:en.num,1)) : 1
      repeat(and(fb:en.const,fb:en.num),1) : 1
      repeat(and(followedby(fb:en.num,fb:en.const),fb:en.num),1) : 1
      fb:en.const : 1
      repeat(and(followedby(fb:en.num,fb:en.const),or(1,2)),1) : 1
      and(fb:en.const,repeat(fb:en.num,1)) : 1
      repeat(and(fb:en.const,or(1,2)),1) : 1
      repeat(followedby(fb:en.num,fb:en.num),1) : 1
      followedby(fb:en.num,fb:en.const) : 1
=======================================================
Test on utterance 41:
  Line 0: regular expression which 
    Top prediction: 
  Line 1: validates only number and min length should be 11 and maximum 16
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
=======================================================
Test on utterance 42:
  Line 0: I need to validate the next pattern: 
    Top prediction: 
  Line 1: starts with <M0> and finish with 4 digits exactly
    Top prediction: startwith(contain(fb:en.const))
    All 30 derivations and their counts: 
      startwith(contain(and(fb:en.const,fb:en.num))) : 1
      startwith(and(contain(fb:en.const),endwith(fb:en.num))) : 1
      startwith(fb:en.const) : 1
      startwith(and(contain(fb:en.const),endwith(contain(fb:en.num)))) : 1
      and(startwith(contain(fb:en.const)),endwith(fb:en.num)) : 1
      startwith(and(contain(fb:en.const),endwith(contain(repeat(fb:en.num,4))))) : 1
      startwith(and(fb:en.const,fb:en.num)) : 1
      startwith(contain(and(fb:en.const,endwith(contain(fb:en.num))))) : 1
      startwith(contain(and(fb:en.const,endwith(contain(repeat(fb:en.num,4)))))) : 1
      startwith(contain(and(fb:en.const,endwith(fb:en.num)))) : 1
      and(startwith(fb:en.const),endwith(fb:en.num)) : 1
      and(fb:en.const,endwith(contain(repeat(fb:en.num,4)))) : 1
      and(startwith(fb:en.const),endwith(contain(repeat(fb:en.num,4)))) : 1
      fb:en.num : 1
      and(fb:en.const,endwith(contain(fb:en.num))) : 1
      and(fb:en.const,endwith(fb:en.num)) : 1
      and(startwith(contain(fb:en.const)),endwith(contain(fb:en.num))) : 1
      and(startwith(fb:en.const),fb:en.num) : 1
      startwith(and(contain(fb:en.const),fb:en.num)) : 1
      startwith(fb:en.num) : 1
      and(fb:en.const,fb:en.num) : 1
      startwith(and(fb:en.const,endwith(fb:en.num))) : 1
      startwith(and(fb:en.const,endwith(contain(fb:en.num)))) : 1
      and(startwith(fb:en.const),endwith(contain(fb:en.num))) : 1
      and(startwith(contain(fb:en.const)),fb:en.num) : 1
      startwith(contain(fb:en.num)) : 1
      and(startwith(contain(fb:en.const)),endwith(contain(repeat(fb:en.num,4)))) : 1
      startwith(contain(fb:en.const)) : 1
      fb:en.const : 1
      startwith(and(fb:en.const,endwith(contain(repeat(fb:en.num,4))))) : 1
=======================================================
Test on utterance 43:
  Line 0: I am trying to validate dollar amount
    Top prediction: 
  Line 1: anything greater than equal to 0.1.
    Top prediction: 
=======================================================
Test on utterance 44:
  Line 0: I need a regular expression that 
    Top prediction: 
  Line 1: satisfy these rules:
    Top prediction: 
  Line 2: The maximum number of decimal point is 3 but a number with no decimal point (e.g 12) should be accepted too
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 2
      fb:en.dp : 2
  Line 3: the value must be at least 0
    Top prediction: 
  Line 4: the value must be less or equal to 99999999999.999
    Top prediction: 
  Line 5: the radix point is DOT (e.g 2.5,
    Top prediction: 
  Line 6: not 2,5)
    Top prediction: 
=======================================================
Test on utterance 45:
  Line 0: I need a regular expression that 
    Top prediction: 
  Line 1: only validates UK mobile numbers. 
    Top prediction: repeat(fb:en.num,1,)
    All 2 derivations and their counts: 
      fb:en.num : 1
      repeat(fb:en.num,1,) : 1
  Line 2: A UK mobile number can be between 10 - 14 digits and either starts with <M0>, 
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 2
      fb:en.const : 1
      and(fb:en.num,fb:en.const) : 1
  Line 3: or omits the <M1> and starts with <M2>. 
    Top prediction: fb:en.const
    All 4 derivations and their counts: 
      and(fb:en.const,fb:en.const) : 1
      and(fb:en.const,startwith(fb:en.const)) : 1
      fb:en.const : 2
      and(fb:en.const,startwith(contain(fb:en.const))) : 1
  Line 4: Importantly, 
    Top prediction: 
  Line 5: if the user adds <M3> it should be rejected.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 46:
  Line 0: I want a regular expression for decimal input, 
    Top prediction: fb:en.dp
    All 1 derivations and their counts: 
      fb:en.dp : 1
  Line 1: which 
    Top prediction: 
  Line 2: can take 4 digits before decimal or <M0> and 2 digits after decimal / <M1>. 
    Top prediction: fb:en.num
derivSize == beamSize
    All 173 derivations and their counts: 
      or(fb:en.dp,and(fb:en.const,repeat(followedby(fb:en.dp,fb:en.num),2))) : 1
      and(or(fb:en.dp,fb:en.const),repeat(followedby(fb:en.dp,fb:en.num),2)) : 1
      and(or(fb:en.dp,fb:en.const),followedby(fb:en.dp,repeat(fb:en.num,2))) : 1
      or(followedby(fb:en.num,fb:en.dp),followedby(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2)))) : 1
      followedby(fb:en.num,followedby(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2)))) : 3
      followedby(fb:en.dp,or(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2)))) : 1
      followedby(fb:en.dp,fb:en.num) : 2
      or(fb:en.dp,followedby(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2)))) : 1
      followedby(fb:en.num,or(fb:en.dp,fb:en.const)) : 2
      followedby(fb:en.num,followedby(fb:en.dp,and(fb:en.const,fb:en.num))) : 3
      or(followedby(fb:en.num,fb:en.dp),and(fb:en.const,repeat(followedby(fb:en.dp,fb:en.num),2))) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),followedby(fb:en.dp,fb:en.num))) : 1
      or(followedby(fb:en.num,fb:en.dp),and(fb:en.const,followedby(fb:en.dp,repeat(fb:en.num,2)))) : 1
      or(fb:en.dp,and(fb:en.const,followedby(fb:en.dp,repeat(fb:en.num,2)))) : 1
      or(fb:en.dp,followedby(fb:en.dp,fb:en.num)) : 1
      or(fb:en.dp,and(fb:en.const,fb:en.dp)) : 1
      followedby(fb:en.dp,followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2))))) : 1
      followedby(fb:en.dp,and(or(fb:en.dp,fb:en.const),fb:en.num)) : 1
      or(fb:en.dp,followedby(fb:en.const,and(fb:en.const,repeat(fb:en.num,2)))) : 1
      or(fb:en.dp,followedby(fb:en.const,and(fb:en.const,fb:en.num))) : 1
      followedby(fb:en.num,or(fb:en.dp,followedby(fb:en.const,fb:en.num))) : 2
      and(or(fb:en.dp,fb:en.const),repeat(fb:en.num,2)) : 1
      and(followedby(fb:en.num,fb:en.const),repeat(fb:en.num,2)) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),repeat(fb:en.dp,2))) : 1
      followedby(fb:en.num,followedby(fb:en.const,and(fb:en.const,fb:en.num))) : 1
      or(fb:en.dp,and(fb:en.const,fb:en.const)) : 1
      fb:en.num : 2
      followedby(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),fb:en.num) : 1
      or(followedby(fb:en.num,fb:en.dp),and(fb:en.const,repeat(fb:en.num,2))) : 1
      or(fb:en.dp,fb:en.const) : 1
      and(fb:en.const,followedby(fb:en.dp,repeat(fb:en.num,2))) : 1
      followedby(fb:en.dp,and(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),repeat(fb:en.num,2))) : 1
      fb:en.dp : 2
      followedby(fb:en.dp,or(fb:en.dp,fb:en.num)) : 1
      and(followedby(fb:en.num,fb:en.const),fb:en.num) : 1
      followedby(fb:en.dp,and(followedby(fb:en.num,fb:en.const),fb:en.num)) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,fb:en.num))) : 2
      and(fb:en.const,repeat(followedby(fb:en.dp,fb:en.num),2)) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),repeat(fb:en.num,2))) : 2
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,followedby(fb:en.const,repeat(fb:en.num,2))))) : 1
      followedby(fb:en.num,followedby(fb:en.const,or(fb:en.dp,and(fb:en.const,fb:en.num)))) : 1
      or(fb:en.dp,and(fb:en.const,repeat(fb:en.const,2))) : 1
      and(or(followedby(fb:en.num,fb:en.dp),fb:en.const),fb:en.num) : 1
      followedby(fb:en.num,followedby(fb:en.const,fb:en.num)) : 3
      or(followedby(fb:en.num,fb:en.dp),followedby(fb:en.dp,fb:en.num)) : 1
      followedby(fb:en.dp,and(followedby(fb:en.num,fb:en.const),repeat(fb:en.num,2))) : 1
      followedby(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2))) : 2
      followedby(fb:en.num,and(fb:en.const,repeat(fb:en.const,2))) : 1
      followedby(fb:en.num,fb:en.const) : 2
      and(or(fb:en.dp,fb:en.const),fb:en.dp) : 1
      followedby(fb:en.num,followedby(fb:en.const,or(fb:en.dp,fb:en.num))) : 1
      or(followedby(fb:en.num,fb:en.dp),fb:en.dp) : 1
      followedby(fb:en.num,followedby(fb:en.const,and(or(fb:en.dp,fb:en.const),fb:en.num))) : 1
      followedby(fb:en.num,or(fb:en.dp,fb:en.dp)) : 1
      followedby(followedby(fb:en.num,fb:en.const),fb:en.num) : 1
      and(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),repeat(fb:en.dp,2)) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,repeat(fb:en.const,2)))) : 1
      or(fb:en.dp,followedby(fb:en.dp,and(fb:en.const,fb:en.num))) : 1
      and(followedby(fb:en.num,fb:en.const),repeat(followedby(fb:en.dp,fb:en.num),2)) : 1
      followedby(fb:en.num,fb:en.num) : 2
      or(followedby(fb:en.num,fb:en.dp),and(fb:en.const,fb:en.num)) : 1
      followedby(fb:en.num,and(fb:en.const,repeat(fb:en.num,2))) : 2
      followedby(fb:en.num,followedby(fb:en.const,and(or(fb:en.dp,fb:en.const),repeat(fb:en.num,2)))) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),repeat(followedby(fb:en.const,fb:en.num),2))) : 1
      followedby(fb:en.num,and(fb:en.const,fb:en.dp)) : 1
      or(fb:en.dp,fb:en.dp) : 1
      followedby(fb:en.dp,followedby(fb:en.num,fb:en.num)) : 1
      and(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),repeat(followedby(fb:en.dp,fb:en.num),2)) : 1
      and(or(followedby(fb:en.num,fb:en.dp),fb:en.const),followedby(fb:en.dp,repeat(fb:en.num,2))) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,repeat(followedby(fb:en.const,fb:en.num),2)))) : 1
      followedby(or(fb:en.dp,fb:en.const),fb:en.num) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),fb:en.dp)) : 1
      followedby(fb:en.num,followedby(or(fb:en.dp,fb:en.const),fb:en.num)) : 2
      followedby(fb:en.num,and(followedby(fb:en.dp,fb:en.const),fb:en.num)) : 1
      followedby(fb:en.dp,and(fb:en.const,fb:en.num)) : 2
      and(followedby(fb:en.num,fb:en.const),repeat(fb:en.dp,2)) : 1
      or(fb:en.dp,and(fb:en.const,followedby(fb:en.const,repeat(fb:en.num,2)))) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),repeat(followedby(fb:en.dp,fb:en.num),2))) : 1
      and(or(followedby(fb:en.num,fb:en.dp),fb:en.const),fb:en.dp) : 1
      or(fb:en.dp,and(fb:en.const,followedby(fb:en.dp,fb:en.num))) : 1
      followedby(fb:en.dp,or(followedby(fb:en.num,fb:en.dp),and(fb:en.const,repeat(fb:en.num,2)))) : 1
      followedby(fb:en.num,and(followedby(fb:en.dp,fb:en.const),repeat(fb:en.num,2))) : 1
      followedby(fb:en.num,and(fb:en.const,repeat(followedby(fb:en.const,fb:en.num),2))) : 1
      followedby(followedby(fb:en.num,fb:en.dp),and(fb:en.const,fb:en.num)) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,fb:en.dp))) : 1
      and(or(followedby(fb:en.num,fb:en.dp),fb:en.const),followedby(fb:en.dp,fb:en.num)) : 1
      followedby(fb:en.dp,or(fb:en.dp,and(fb:en.const,fb:en.num))) : 1
      fb:en.const : 1
      and(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),followedby(fb:en.dp,fb:en.num)) : 1
      followedby(fb:en.num,and(fb:en.const,repeat(followedby(fb:en.dp,fb:en.num),2))) : 1
      and(fb:en.const,repeat(fb:en.num,2)) : 1
      and(or(followedby(fb:en.num,fb:en.dp),fb:en.const),repeat(fb:en.dp,2)) : 1
      and(or(fb:en.dp,fb:en.const),fb:en.num) : 1
      and(fb:en.const,repeat(fb:en.dp,2)) : 1
      or(followedby(fb:en.num,fb:en.dp),fb:en.num) : 1
      or(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2))) : 1
      and(fb:en.const,fb:en.dp) : 1
      or(fb:en.dp,and(fb:en.const,followedby(fb:en.const,fb:en.num))) : 1
      followedby(fb:en.num,and(fb:en.const,followedby(fb:en.const,fb:en.num))) : 1
      or(followedby(fb:en.num,fb:en.dp),followedby(fb:en.dp,and(fb:en.const,fb:en.num))) : 1
      followedby(fb:en.num,or(fb:en.dp,followedby(fb:en.const,and(fb:en.const,repeat(fb:en.num,2))))) : 1
      followedby(fb:en.num,or(fb:en.dp,fb:en.num)) : 2
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),fb:en.num)) : 2
      followedby(fb:en.num,or(fb:en.dp,followedby(fb:en.const,and(fb:en.const,fb:en.num)))) : 1
      followedby(fb:en.dp,followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,fb:en.num)))) : 1
      followedby(or(followedby(fb:en.num,fb:en.dp),fb:en.const),fb:en.num) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),followedby(fb:en.dp,repeat(fb:en.num,2)))) : 1
      and(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),fb:en.dp) : 1
      or(fb:en.dp,fb:en.num) : 1
      and(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),fb:en.num) : 1
      followedby(fb:en.dp,or(followedby(fb:en.num,fb:en.dp),fb:en.num)) : 1
      followedby(fb:en.dp,and(or(followedby(fb:en.num,fb:en.dp),fb:en.const),repeat(fb:en.num,2))) : 1
      or(followedby(fb:en.num,fb:en.dp),and(fb:en.const,followedby(fb:en.dp,fb:en.num))) : 1
      and(fb:en.const,fb:en.num) : 1
      followedby(fb:en.num,fb:en.dp) : 2
      followedby(fb:en.num,and(fb:en.const,repeat(fb:en.dp,2))) : 1
      followedby(fb:en.dp,followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),fb:en.num))) : 1
      and(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),repeat(fb:en.num,2)) : 1
      followedby(fb:en.num,or(fb:en.dp,followedby(fb:en.dp,and(fb:en.const,fb:en.num)))) : 1
      followedby(fb:en.num,followedby(fb:en.const,or(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2))))) : 1
      followedby(fb:en.num,or(fb:en.dp,followedby(fb:en.dp,fb:en.num))) : 1
      followedby(fb:en.dp,followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),repeat(fb:en.num,2)))) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,repeat(followedby(fb:en.dp,fb:en.num),2)))) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,followedby(fb:en.dp,fb:en.num)))) : 1
      and(or(fb:en.dp,fb:en.const),repeat(fb:en.dp,2)) : 1
      followedby(followedby(fb:en.num,fb:en.dp),fb:en.num) : 1
      followedby(fb:en.const,fb:en.num) : 1
      or(followedby(fb:en.num,fb:en.dp),and(fb:en.const,repeat(fb:en.dp,2))) : 1
      or(fb:en.dp,and(fb:en.const,fb:en.num)) : 1
      or(followedby(fb:en.num,fb:en.dp),and(fb:en.const,fb:en.dp)) : 1
      followedby(followedby(fb:en.num,fb:en.dp),and(fb:en.const,repeat(fb:en.num,2))) : 1
      followedby(fb:en.num,and(fb:en.const,followedby(fb:en.const,repeat(fb:en.num,2)))) : 1
      and(followedby(fb:en.num,fb:en.const),followedby(fb:en.dp,repeat(fb:en.num,2))) : 1
      followedby(fb:en.num,followedby(fb:en.dp,and(or(fb:en.dp,fb:en.const),fb:en.num))) : 1
      and(fb:en.const,followedby(fb:en.dp,fb:en.num)) : 1
      followedby(fb:en.num,followedby(fb:en.dp,fb:en.num)) : 3
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),followedby(fb:en.const,repeat(fb:en.num,2)))) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),fb:en.const)) : 1
      followedby(fb:en.dp,or(followedby(fb:en.num,fb:en.dp),and(fb:en.const,fb:en.num))) : 1
      followedby(fb:en.dp,followedby(fb:en.num,and(fb:en.const,fb:en.num))) : 1
      followedby(fb:en.dp,followedby(fb:en.num,and(fb:en.const,repeat(fb:en.num,2)))) : 1
      followedby(fb:en.dp,and(or(fb:en.dp,fb:en.const),repeat(fb:en.num,2))) : 1
      followedby(fb:en.num,and(fb:en.const,fb:en.num)) : 2
      followedby(fb:en.dp,followedby(fb:en.num,or(fb:en.dp,fb:en.num))) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2)))) : 2
      followedby(fb:en.dp,and(or(followedby(fb:en.num,fb:en.dp),fb:en.const),fb:en.num)) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),followedby(fb:en.const,fb:en.num))) : 1
      or(fb:en.dp,and(fb:en.const,repeat(followedby(fb:en.const,fb:en.num),2))) : 1
      followedby(fb:en.num,and(or(fb:en.dp,fb:en.const),repeat(fb:en.const,2))) : 1
      and(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),followedby(fb:en.dp,repeat(fb:en.num,2))) : 1
      and(or(followedby(fb:en.num,fb:en.dp),fb:en.const),repeat(followedby(fb:en.dp,fb:en.num),2)) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,followedby(fb:en.const,fb:en.num)))) : 1
      and(or(followedby(fb:en.num,fb:en.dp),fb:en.const),repeat(fb:en.num,2)) : 1
      followedby(fb:en.num,followedby(fb:en.dp,or(fb:en.dp,and(fb:en.const,fb:en.num)))) : 1
      or(fb:en.dp,and(fb:en.const,repeat(fb:en.dp,2))) : 1
      followedby(fb:en.dp,and(followedby(fb:en.num,or(fb:en.dp,fb:en.const)),fb:en.num)) : 1
      followedby(fb:en.num,and(fb:en.const,fb:en.const)) : 1
      followedby(fb:en.num,followedby(fb:en.dp,and(or(fb:en.dp,fb:en.const),repeat(fb:en.num,2)))) : 1
      or(followedby(fb:en.num,fb:en.dp),followedby(fb:en.const,fb:en.num)) : 1
      followedby(fb:en.num,followedby(fb:en.dp,or(fb:en.dp,fb:en.num))) : 1
      and(followedby(fb:en.num,fb:en.const),fb:en.dp) : 1
      and(or(fb:en.dp,fb:en.const),followedby(fb:en.dp,fb:en.num)) : 1
      followedby(fb:en.num,followedby(fb:en.const,and(fb:en.const,repeat(fb:en.num,2)))) : 1
      or(followedby(fb:en.num,fb:en.dp),fb:en.const) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,followedby(fb:en.dp,repeat(fb:en.num,2))))) : 1
      followedby(fb:en.num,or(fb:en.dp,followedby(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2))))) : 1
      and(followedby(fb:en.num,fb:en.const),followedby(fb:en.dp,fb:en.num)) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,fb:en.const))) : 1
      or(fb:en.dp,followedby(fb:en.const,fb:en.num)) : 2
      followedby(fb:en.num,followedby(fb:en.dp,or(fb:en.dp,and(fb:en.const,repeat(fb:en.num,2))))) : 1
      followedby(fb:en.num,and(fb:en.const,followedby(fb:en.dp,repeat(fb:en.num,2)))) : 1
      followedby(fb:en.num,or(fb:en.dp,and(fb:en.const,repeat(fb:en.dp,2)))) : 1
      followedby(fb:en.num,and(fb:en.const,followedby(fb:en.dp,fb:en.num))) : 1
  Line 3: 5 digit number without decimal is invalid.
    Top prediction: fb:en.num
    All 7 derivations and their counts: 
      fb:en.num : 2
      repeat(not(fb:en.num),5) : 1
      fb:en.dp : 1
      repeat(fb:en.num,5) : 2
      not(fb:en.num) : 1
      repeat(fb:en.dp,5) : 1
      not(repeat(fb:en.num,5)) : 1
=======================================================
Test on utterance 47:
  Line 0: I need a regular expression that 
    Top prediction: 
  Line 1: validates a decimal number which 
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
  Line 2: includes <M0> , <M1> sign as well.
    Top prediction: contain(fb:en.const)
    All 2 derivations and their counts: 
      fb:en.const : 2
      contain(fb:en.const) : 2
=======================================================
Test on utterance 48:
  Line 0: I need to validate a string that 
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 1: contains underscore ( <M0> ) in between the numbers. 
    Top prediction: contain(fb:en.const)
    All 4 derivations and their counts: 
      fb:en.num : 1
      fb:en.const : 1
      contain(fb:en.num) : 1
      contain(fb:en.const) : 1
  Line 2: <M1> character is an optional. 
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
  Line 3: Only condition is, 
    Top prediction: 
  Line 4: it should be between the numbers.
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
=======================================================
Test on utterance 49:
  Line 0: I need some help in finding how to write a validation expression to validate a string representing addition of digits.
    Top prediction: fb:en.any
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.any : 1
=======================================================
Test on utterance 50:
  Line 0: Requirement is that 
    Top prediction: 
  Line 1: total number of <M0> with the string can only be one.
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.const : 1
      fb:en.any : 1
=======================================================
Test on utterance 51:
  Line 0: I need to match only strings that 
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 1: include one character / between numbers or integer numbers.
    Top prediction: contain(fb:en.let)
    All 15 derivations and their counts: 
      fb:en.num : 3
      contain(repeat(fb:en.any,1)) : 1
      contain(fb:en.any) : 1
      contain(or(fb:en.num,fb:en.num)) : 2
      contain(repeat(fb:en.num,1)) : 3
      fb:en.let : 1
      or(fb:en.num,fb:en.num) : 2
      contain(fb:en.let) : 1
      or(contain(repeat(fb:en.num,1)),fb:en.num) : 2
      or(contain(fb:en.num),fb:en.num) : 2
      contain(repeat(fb:en.let,1)) : 1
      contain(repeat(or(fb:en.num,fb:en.num),1)) : 2
      contain(or(repeat(fb:en.num,1),fb:en.num)) : 2
      fb:en.any : 1
      contain(fb:en.num) : 3
=======================================================
Test on utterance 52:
  Line 0: Allows only the following characters:
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
  Line 1: Letters, numbers, spaces and any of the following characters <M0> <M1> <M2> <M3> <M4> <M5> <M6>
    Top prediction: fb:en.const
    All 7 derivations and their counts: 
      fb:en.num : 1
      followedby(fb:en.any,fb:en.const) : 1
      fb:en.let : 2
      fb:en.const : 24
      fb:en.any : 2
      followedby(fb:en.let,fb:en.const) : 1
      followedby(fb:en.const,fb:en.const) : 6
=======================================================
Test on utterance 53:
  Line 0: User allowed to enter two characters after <M0>
    Top prediction: fb:en.const
    All 10 derivations and their counts: 
      followedby(fb:en.const,fb:en.let) : 6
      followedby(fb:en.const,repeat(fb:en.let,2)) : 1
      repeat(fb:en.const,2) : 1
      followedby(fb:en.const,repeat(fb:en.any,2)) : 1
      followedby(fb:en.const,fb:en.any) : 6
      fb:en.let : 1
      fb:en.const : 8
      fb:en.any : 1
      repeat(followedby(fb:en.const,fb:en.let),2) : 1
      repeat(followedby(fb:en.const,fb:en.any),2) : 1
=======================================================
Test on utterance 54:
  Line 0: Validating rules are follow
    Top prediction: 
  Line 1: Input is last name, first name i.e. separated by <M0>.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 2: Must have at least two characters while using wild card search.
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
  Line 3: Valid wildcard character is ' <M1> ' only.
    Top prediction: fb:en.let
    All 3 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
      fb:en.const : 1
  Line 4: At most two wildcard characters can be used.
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
  Line 5: No consecutive wild cards.
    Top prediction: 
  Line 6: If no wild card used no constraint on length of characters in both last and first name.
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
=======================================================
Test on utterance 55:
  Line 0: The validation will pass only if
    Top prediction: 
  Line 1: the number has precisely two decimal places
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
  Line 2: there is at least one digit before the decimal point. (could be zero)
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
      followedby(fb:en.num,fb:en.dp) : 1
  Line 3: the number before the decimal point can not begin with more than one zero.
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
      followedby(fb:en.num,fb:en.dp) : 1
=======================================================
Test on utterance 56:
  Line 0: the first letter of each string is in upper case
    Top prediction: fb:en.let
    All 3 derivations and their counts: 
      fb:en.cap : 1
      fb:en.let : 1
      fb:en.any : 1
=======================================================
Test on utterance 57:
  Line 0: allow only numbers
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 3
      repeat(fb:en.num,1,) : 1
  Line 1: maxmium two decimals
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.dp : 3
      repeat(fb:en.dp,2) : 1
  Line 2: max one <M0> (,) and one <M1> symbol in front of the number ( optional ).
    Top prediction: fb:en.const
    All 4 derivations and their counts: 
      fb:en.num : 1
      repeat(fb:en.const,1,1) : 2
      repeat(fb:en.num,1,1) : 1
      fb:en.const : 2
=======================================================
Test on utterance 58:
  Line 0: it doesn't start with a <M0>,
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 1: doesn't contain a <M1>, 
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 2: and doesn't end with a <M2>.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 59:
  Line 0: We like to validate following with Regex:
    Top prediction: 
  Line 1: string may contain 0 or more alphabets, digits, <M0> OR
    Top prediction: fb:en.any
    All 4 derivations and their counts: 
      fb:en.num : 1
      fb:en.let : 1
      fb:en.any : 1
      fb:en.const : 1
  Line 2: string may contain literals <M1> or <M2> (0 or more times in any order)
    Top prediction: fb:en.any
    All 4 derivations and their counts: 
      or(fb:en.const,fb:en.any) : 1
      fb:en.any : 2
      fb:en.const : 2
      or(fb:en.const,fb:en.const) : 1
=======================================================
Test on utterance 60:
  Line 0: I want to write a regular expression using jQuery to validate input fields which 
    Top prediction: 
  Line 1: will not allow special char at end and the string length should be in between 3 - 25.
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
=======================================================
Test on utterance 61:
  Line 0: write a regular expression for validating a organisation name which 
    Top prediction: 
  Line 1: allows Alphanumeric as the starting characters and only special characters like <M0> , <M1> , <M2> and <M3>.
    Top prediction: fb:en.letnum
    All 32 derivations and their counts: 
      and(fb:en.const,fb:en.const) : 1
      and(fb:en.any,fb:en.const) : 4
      and(fb:en.any,repeat(fb:en.any,1,)) : 1
      fb:en.let : 2
      and(fb:en.any,and(repeat(fb:en.const,1,),fb:en.const)) : 1
      and(fb:en.let,fb:en.const) : 4
      and(fb:en.let,repeat(and(fb:en.const,fb:en.const),1,)) : 1
      and(fb:en.any,fb:en.sp) : 1
      and(and(fb:en.any,fb:en.const),fb:en.const) : 1
      and(fb:en.let,fb:en.sp) : 1
      fb:en.sp : 1
      and(fb:en.any,repeat(and(fb:en.const,fb:en.const),1,)) : 1
      and(fb:en.any,repeat(fb:en.let,1,)) : 1
      and(fb:en.let,fb:en.any) : 1
      and(fb:en.let,and(repeat(fb:en.const,1,),fb:en.const)) : 1
      fb:en.letnum : 1
      and(and(fb:en.let,repeat(fb:en.const,1,)),fb:en.const) : 1
      and(fb:en.let,repeat(fb:en.any,1,)) : 1
      and(fb:en.let,and(fb:en.const,fb:en.const)) : 1
      and(fb:en.let,repeat(fb:en.let,1,)) : 1
      and(fb:en.let,repeat(fb:en.sp,1,)) : 1
      and(fb:en.let,repeat(fb:en.const,1,)) : 4
      and(fb:en.let,fb:en.let) : 1
      and(fb:en.any,repeat(fb:en.const,1,)) : 4
      and(fb:en.any,repeat(fb:en.sp,1,)) : 1
      and(fb:en.any,fb:en.let) : 1
      and(fb:en.any,and(fb:en.const,fb:en.const)) : 1
      and(and(fb:en.any,repeat(fb:en.const,1,)),fb:en.const) : 1
      fb:en.any : 2
      fb:en.const : 4
      and(fb:en.any,fb:en.any) : 1
      and(and(fb:en.let,fb:en.const),fb:en.const) : 1
=======================================================
Test on utterance 62:
  Line 0: validate a set of double number with <M0> delimited
    Top prediction: contain(sep(fb:en.const))
    All 4 derivations and their counts: 
      fb:en.num : 1
      sep(fb:en.const) : 1
      fb:en.const : 1
      contain(sep(fb:en.const)) : 1
=======================================================
Test on utterance 63:
  Line 0: I need regular expression for validating version number
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 8
=======================================================
Test on utterance 64:
  Line 0: What is the regex that 
    Top prediction: 
  Line 1: matches 6 characters, 
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
  Line 2: first is a letter, 
    Top prediction: repeat(fb:en.let,1)
    All 2 derivations and their counts: 
      repeat(fb:en.let,1) : 1
      fb:en.let : 1
  Line 3: others are numbers
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 3
=======================================================
Test on utterance 65:
  Line 0: I'm trying to make a regular expression that 
    Top prediction: 
  Line 1: validates positive natural numbers from three digits to 9 digits and separates the thousand unit and the million unit with a <M0>
    Top prediction: and(fb:en.num,fb:en.const)
    All 18 derivations and their counts: 
      repeat(fb:en.const,1000) : 1
      fb:en.num : 3
      and(repeat(fb:en.num,3),sep(fb:en.const)) : 1
      repeat(fb:en.const,3) : 1
      and(repeat(fb:en.num,9),fb:en.const) : 1
      repeat(and(fb:en.num,sep(fb:en.const)),3) : 1
      sep(fb:en.const) : 1
      repeat(and(fb:en.num,sep(fb:en.const)),9) : 1
      and(fb:en.num,fb:en.const) : 10
      and(repeat(fb:en.num,9),sep(fb:en.const)) : 1
      repeat(fb:en.const,1000000) : 1
      repeat(and(fb:en.num,fb:en.const),3) : 1
      and(fb:en.num,sep(fb:en.const)) : 10
      fb:en.const : 22
      and(repeat(fb:en.num,3),fb:en.const) : 1
      repeat(and(fb:en.num,fb:en.const),9) : 1
      repeat(fb:en.const,9) : 1
      contain(fb:en.const) : 1
=======================================================
Test on utterance 66:
  Line 0: First Name and Last Name Only with only 2 words with only 1 <M0>.
    Top prediction: repeat(fb:en.any,1)
    All 4 derivations and their counts: 
      repeat(fb:en.const,1) : 1
      repeat(fb:en.any,1) : 1
      fb:en.any : 1
      fb:en.const : 1
=======================================================
Test on utterance 67:
  Line 0: the expression is a alphanumeric one(where
    Top prediction: fb:en.letnum
    All 1 derivations and their counts: 
      fb:en.letnum : 1
  Line 1: the alphabets are optional) where 
    Top prediction: fb:en.let
    All 1 derivations and their counts: 
      fb:en.let : 1
  Line 2: the alphabets can be only <M0> | <M1> | <M2> | <M3> | <M4> | <M5> | <M6> | <M7> | <M8> | <M9> and can appear only after the numerals. 
    Top prediction: fb:en.let
    All 4 derivations and their counts: 
      fb:en.num : 1
      fb:en.let : 1
      fb:en.const : 10
      and(fb:en.const,fb:en.num) : 1
  Line 3: Also if any character can come before any numerals that
    Top prediction: fb:en.any
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.let : 1
      fb:en.any : 3
  Line 4: can only be a <M10>.
    Top prediction: 
=======================================================
Test on utterance 68:
  Line 0: The name must only consist of letters, numbers and one or more single <M0> (not in the beginning or end). 
    Top prediction: fb:en.let
    All 5 derivations and their counts: 
      fb:en.num : 1
      fb:en.let : 1
      and(fb:en.num,repeat(fb:en.const,1)) : 1
      fb:en.const : 1
      and(fb:en.num,fb:en.const) : 1
  Line 1: The minimum length is 3 characters.
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
=======================================================
Test on utterance 69:
  Line 0: I would like to validate a string format that 
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 1: should only contain only numbers with also following conditions both satisfied: 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 2: If it is a integer number, the maximum number of digits is 5. 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 4
  Line 3: If it is a number with decimal (or decimal fraction),
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 2
  Line 4: the maximum digits after decimal mark is two. 
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 1
      followedby(fb:en.dp,fb:en.num) : 1
      fb:en.dp : 1
  Line 5: NOTE:
    Top prediction: 
  Line 6: value use <M0> or dot as decimal point. 
    Top prediction: fb:en.const
    All 3 derivations and their counts: 
      fb:en.dp : 2
      or(fb:en.const,fb:en.dp) : 2
      fb:en.const : 1
  Line 7: Please bear in mind that 
    Top prediction: 
  Line 8: both of the two conditions have to be satisfied.
    Top prediction: 
=======================================================
Test on utterance 70:
  Line 0: I need a regular expression to validate single digit within range of [1-5] followed by alphabet <M0> and followed by optional alphabet <M1>
    Top prediction: and(fb:en.const,fb:en.const)
    All 14 derivations and their counts: 
      fb:en.num : 1
      and(fb:en.const,fb:en.const) : 19
      and(followedby(fb:en.let,fb:en.const),fb:en.const) : 1
      and(fb:en.const,followedby(fb:en.let,fb:en.const)) : 19
      fb:en.let : 2
      and(followedby(fb:en.let,fb:en.const),followedby(fb:en.let,fb:en.const)) : 1
      and(fb:en.const,fb:en.let) : 1
      followedby(fb:en.let,and(fb:en.const,followedby(fb:en.let,fb:en.const))) : 1
      optional(fb:en.const) : 1
      followedby(fb:en.let,and(fb:en.const,fb:en.const)) : 1
      fb:en.const : 26
      followedby(fb:en.let,fb:en.const) : 3
      followedby(and(fb:en.const,fb:en.let),fb:en.const) : 1
      followedby(fb:en.const,fb:en.const) : 1
=======================================================
Test on utterance 71:
  Line 0: I need a regular expression validation expression that
    Top prediction: 
  Line 1: will 
    Top prediction: 
  Line 2: ALLOW positive number ( 0-9 ), <M0> and <M1>
    Top prediction: fb:en.const
    All 3 derivations and their counts: 
      fb:en.num : 1
      and(fb:en.const,fb:en.const) : 8
      fb:en.const : 11
  Line 3: DISALLOW letter (a-z), any other letter or symbol except <M0> and <M1>
    Top prediction: or(fb:en.let,fb:en.const)
    All 19 derivations and their counts: 
      not(fb:en.const) : 3
      and(fb:en.const,fb:en.const) : 14
      and(not(fb:en.const),fb:en.const) : 2
      or(not(fb:en.let),and(fb:en.const,fb:en.const)) : 1
      and(or(not(fb:en.let),fb:en.const),fb:en.const) : 1
      not(and(or(fb:en.let,fb:en.const),fb:en.const)) : 1
      not(fb:en.any) : 1
      fb:en.let : 2
      or(fb:en.let,fb:en.const) : 11
      and(or(fb:en.let,fb:en.const),fb:en.const) : 10
      not(or(fb:en.let,and(fb:en.const,fb:en.const))) : 1
      and(not(or(fb:en.let,fb:en.const)),fb:en.const) : 1
      not(and(fb:en.const,fb:en.const)) : 2
      or(fb:en.let,and(fb:en.const,fb:en.const)) : 10
      or(not(fb:en.let),fb:en.const) : 2
      fb:en.const : 17
      fb:en.any : 1
      not(fb:en.let) : 2
      not(or(fb:en.let,fb:en.const)) : 2
=======================================================
Test on utterance 72:
  Line 0: at least 6 characters
    Top prediction: fb:en.let
    All 6 derivations and their counts: 
      repeat(fb:en.let,6) : 1
      repeat(fb:en.let,6,) : 1
      repeat(fb:en.any,6,) : 1
      fb:en.let : 4
      fb:en.any : 4
      repeat(fb:en.any,6) : 1
  Line 1: no <M0>
    Top prediction: fb:en.const
    All 2 derivations and their counts: 
      not(fb:en.const) : 1
      fb:en.const : 2
  Line 2: at least one digit
    Top prediction: fb:en.num
    All 3 derivations and their counts: 
      fb:en.num : 4
      repeat(fb:en.num,1) : 1
      repeat(fb:en.num,1,) : 1
  Line 3: at least one uppercase
    Top prediction: fb:en.cap
    All 3 derivations and their counts: 
      fb:en.cap : 4
      repeat(fb:en.cap,1,) : 1
      repeat(fb:en.cap,1) : 1
  Line 4: at least one lowercase
    Top prediction: fb:en.low
    All 3 derivations and their counts: 
      fb:en.low : 4
      repeat(fb:en.low,1,) : 1
      repeat(fb:en.low,1) : 1
  Line 5: at least one special character: 
    Top prediction: fb:en.sp
    All 6 derivations and their counts: 
      repeat(fb:en.let,1,) : 1
      fb:en.sp : 1
      repeat(fb:en.sp,1,) : 1
      fb:en.let : 1
      fb:en.any : 1
      repeat(fb:en.any,1,) : 1
  Line 6: <M1> <M2> <M3> <M4> <M5> <M6> <M7> <M8> <M9> <M10> <M11>
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 9
=======================================================
Test on utterance 73:
  Line 0: I would like regex to be a whole number with thousands separated with a <M0>. 
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.const : 1
  Line 1: No decimal. 
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.dp : 1
      not(fb:en.dp) : 1
  Line 2: No <M1>.
    Top prediction: fb:en.const
    All 2 derivations and their counts: 
      not(fb:en.const) : 1
      fb:en.const : 1
=======================================================
Test on utterance 74:
  Line 0: I'm looking for a regular expression that 
    Top prediction: 
  Line 1: will match text given the following requirements:
    Top prediction: 
  Line 2: contains only 10 digits (only numbers)
    Top prediction: contain(repeat(fb:en.num,1,))
    All 5 derivations and their counts: 
      fb:en.num : 2
      contain(repeat(fb:en.num,1,)) : 2
      contain(repeat(fb:en.num,10)) : 2
      contain(repeat(repeat(fb:en.num,10),1,)) : 2
      contain(fb:en.num) : 2
  Line 3: starts with <M0>.
    Top prediction: startwith(contain(fb:en.const))
    All 3 derivations and their counts: 
      startwith(fb:en.const) : 1
      startwith(contain(fb:en.const)) : 1
      fb:en.const : 1
=======================================================
Test on utterance 75:
  Line 0: Need a regular expression to validate number with <M0> separator.
    Top prediction: contain(sep(fb:en.const))
    All 4 derivations and their counts: 
      fb:en.num : 1
      sep(fb:en.const) : 1
      fb:en.const : 1
      contain(sep(fb:en.const)) : 1
=======================================================
Test on utterance 76:
  Line 0: valid characters are alpha-numeric and <M0> (period). 
    Top prediction: fb:en.let
    All 5 derivations and their counts: 
      fb:en.num : 1
      fb:en.let : 1
      fb:en.any : 1
      fb:en.const : 1
      and(fb:en.num,fb:en.const) : 1
  Line 1: The patterns are %d4% and %t7%. 
    Top prediction: 
  Line 2: So <M1> is not valid by itself, 
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 3: but has to be part of these specific patterns.
    Top prediction: 
=======================================================
Test on utterance 77:
  Line 0: The input box should accept alphanumeric with no <M0> and it should also allow the user to use the characters like <M1> <M2> <M3> <M4> <M5>  <M6> <M7> any where in the string,
    Top prediction: fb:en.letnum
    All 7 derivations and their counts: 
      and(fb:en.const,fb:en.let) : 1
      and(fb:en.const,fb:en.const) : 7
      and(fb:en.const,fb:en.any) : 3
      fb:en.letnum : 1
      fb:en.let : 1
      fb:en.const : 8
      fb:en.any : 3
  Line 1: except these characters non of the other characters should be allowed like ( <M8>, <M9>, <M10> etc ). 
    Top prediction: not(fb:en.let)
    All 8 derivations and their counts: 
      not(fb:en.const) : 2
      not(not(fb:en.any)) : 2
      not(not(fb:en.let)) : 2
      not(fb:en.any) : 3
      fb:en.let : 2
      fb:en.any : 2
      fb:en.const : 2
      not(fb:en.let) : 3
  Line 2: It should not allow leading/trailing <M11> also.
    Top prediction: 
=======================================================
Test on utterance 78:
  Line 0: Should allow only alphanumeric with no <M0> and no other characters including ( <M1> ). 
    Top prediction: fb:en.letnum
    All 10 derivations and their counts: 
      and(fb:en.const,fb:en.let) : 1
      and(fb:en.const,not(fb:en.const)) : 1
      and(fb:en.const,fb:en.const) : 1
      and(fb:en.const,not(fb:en.let)) : 1
      and(fb:en.const,fb:en.any) : 1
      fb:en.letnum : 1
      fb:en.let : 1
      fb:en.const : 2
      fb:en.any : 1
      and(fb:en.const,not(fb:en.any)) : 1
  Line 1: It should not allow leading/trailing <M2> also.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 79:
  Line 0: I'm trying to use regular expressions to match a string that 
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 1: does not contain the sequence of characters of a less than symbol ( <M0> ) followed by a non <M1>.
    Top prediction: fb:en.let
    All 3 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
      fb:en.const : 2
=======================================================
Test on utterance 80:
  Line 0: the number with 10 or more digits and that 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 2
  Line 1: number should not have <M0> symbol in front of it.
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.const : 1
=======================================================
Test on utterance 81:
  Line 0: It should allow only one <M0> between words. 
    Top prediction: fb:en.const
    All 2 derivations and their counts: 
      fb:en.const : 1
      fb:en.any : 1
  Line 1: That
    Top prediction: 
  Line 2: is, 
    Top prediction: 
  Line 3: total number of <M1> between words or characters should only be one.
    Top prediction: fb:en.num
    All 6 derivations and their counts: 
      or(fb:en.any,fb:en.let) : 1
      fb:en.num : 1
      fb:en.let : 1
      fb:en.const : 1
      fb:en.any : 2
      or(fb:en.any,fb:en.any) : 1
  Line 4: It should ignore leading and trailing <M2>.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 82:
  Line 0: I want to limit mamimum total digit counts are 5. 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 1: And decimal numbers are 2 positions for maximum, 
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 1
  Line 2: cannot exceed 2 digits, 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 3: but need to valid total word count is not large than 5.
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
=======================================================
Test on utterance 83:
  Line 0: I'm trying to validate a form using regular expressions, 
    Top prediction: 
  Line 1: the conditions are:
    Top prediction: 
  Line 2: It has to be a numeric value
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 3: It CAN have up to three decimal places(<M0>,<M1>,<M2> are allowed too)
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.dp : 1
      fb:en.const : 3
  Line 4: It has to be divided by a comma(<M0>)
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 84:
  Line 0: I am trying to make a regular expression that 
    Top prediction: 
  Line 1: validates letters, numbers and <M0> ONLY.”
    Top prediction: fb:en.let
    All 4 derivations and their counts: 
      fb:en.num : 1
      fb:en.let : 1
      fb:en.const : 1
      and(fb:en.num,fb:en.const) : 1
=======================================================
Test on utterance 85:
  Line 0: The input box should accept only if either 
    Top prediction: 
  Line 1: first 2 letters <M0> + 6 numeric or 
    Top prediction: repeat(fb:en.let,1)
    All 12 derivations and their counts: 
      fb:en.num : 1
      repeat(fb:en.let,1) : 1
      repeat(repeat(fb:en.const,2),1) : 1
      repeat(fb:en.num,1) : 1
      repeat(fb:en.let,1,2) : 1
      repeat(fb:en.const,1) : 1
      fb:en.let : 1
      repeat(repeat(fb:en.num,2),1) : 1
      fb:en.const : 1
      repeat(fb:en.num,1,2) : 1
      repeat(fb:en.const,1,2) : 1
      repeat(repeat(fb:en.let,2),1) : 1
  Line 2: 8 numeric
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 2
      repeat(fb:en.num,8) : 1
=======================================================
Test on utterance 86:
  Line 0: a regular expression for validating a string with alphanumeric characters and <M0>, 
    Top prediction: fb:en.any
    All 6 derivations and their counts: 
      and(fb:en.any,fb:en.const) : 1
      fb:en.letnum : 1
      fb:en.let : 1
      fb:en.any : 2
      fb:en.const : 1
      and(fb:en.let,fb:en.const) : 1
  Line 1: while also not allowing leading or trailing <M1>
    Top prediction: fb:en.const
    All 3 derivations and their counts: 
      not(fb:en.const) : 1
      endwith(fb:en.const) : 1
      fb:en.const : 8
=======================================================
Test on utterance 87:
  Line 0: Decimal numbers up to 3 decimal places which 
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.dp : 2
  Line 1: are greater than zero
    Top prediction: 
=======================================================
Test on utterance 88:
  Line 0: The value can have at max 3 decimals (but also none) with <M0> as the separator.
    Top prediction: fb:en.dp
    All 2 derivations and their counts: 
      fb:en.dp : 1
      fb:en.const : 1
=======================================================
Test on utterance 89:
  Line 0: I want to use a Regular expression validator in my line edit that 
    Top prediction: 
  Line 1: doesn't allow to write dot (.) right after dot (.).
    Top prediction: fb:en.dp
    All 1 derivations and their counts: 
      fb:en.dp : 2
=======================================================
Test on utterance 90:
  Line 0: I want regex that 
    Top prediction: 
  Line 1: only validates that 
    Top prediction: 
  Line 2: the field contains digits, but that
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 3: does not care about how many.
    Top prediction: 
=======================================================
Test on utterance 91:
  Line 0: The rules are:
    Top prediction: 
  Line 1: The string must be 10 - 15 total characters in length.
    Top prediction: fb:en.any
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 2
  Line 2: Must contain exactly 10 digits within string.
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.any : 1
  Line 3: Can contain " <M0> ", " <M1> " , "<M2>", " <M3> ", or " <M4> " delimiters within the string.
    Top prediction: fb:en.const
    All 2 derivations and their counts: 
      fb:en.const : 5
      fb:en.any : 1
  Line 4: It doesn't matter how many delimiters are grouped as long as numbers are grouped in {3}{3}{4}.
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
=======================================================
Test on utterance 92:
  Line 0: I am now in need of a Reg Exp (for validation putsposes) that 
    Top prediction: 
  Line 1: checks that 
    Top prediction: 
  Line 2: the user enters a number according to the following rules.
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 3: no alpha characters
    Top prediction: fb:en.let
    All 4 derivations and their counts: 
      not(fb:en.any) : 1
      fb:en.let : 3
      fb:en.any : 3
      not(fb:en.let) : 1
  Line 4: can have decimal
    Top prediction: contain(fb:en.dp)
    All 2 derivations and their counts: 
      contain(fb:en.dp) : 1
      fb:en.dp : 3
  Line 5: can have <M0> for the thousands, but the <M1> must be correctly placed
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 2
=======================================================
Test on utterance 93:
  Line 0: I'm trying to validate an input field to accept x OR x+y where 
    Top prediction: 
  Line 1: x and y are whole numbers from 1-10.
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
=======================================================
Test on utterance 94:
  Line 0: I'm trying to write a regular expression to validate a number that 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 1: is either just a <M0> OR at least 1000 and that 
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 2: also allows a <M1> for a thousand separator.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 95:
  Line 0: I am writing a regular expression to validate a zip code, 
    Top prediction: 
  Line 1: where it should have exactly a length of 6 characters, 
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
  Line 2: the first 3 characters are digits, 
    Top prediction: fb:en.let
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.let : 1
      fb:en.any : 1
  Line 3: the last 2 also, 
    Top prediction: 
  Line 4: but the character 4 should be a <M0>.
    Top prediction: fb:en.let
    All 3 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
      fb:en.const : 1
=======================================================
Test on utterance 96:
  Line 0: I want a regular expression that 
    Top prediction: 
  Line 1: validates a string of length 1 which 
    Top prediction: fb:en.any
    All 1 derivations and their counts: 
      fb:en.any : 1
  Line 2: has either the characters <M0> or <M1> (case insensitive) at the Begin
    Top prediction: contain(fb:en.let)
    All 9 derivations and their counts: 
      contain(fb:en.any) : 1
      contain(or(fb:en.const,fb:en.const)) : 1
      or(contain(fb:en.const),fb:en.const) : 1
      fb:en.let : 1
      contain(fb:en.let) : 1
      fb:en.any : 1
      fb:en.const : 2
      contain(fb:en.const) : 2
      or(fb:en.const,fb:en.const) : 1
=======================================================
Test on utterance 97:
  Line 0: start and finish with a <M0> sign and can contain any number of characters in-between.
    Top prediction: startwith(fb:en.const)
    All 8 derivations and their counts: 
      fb:en.num : 1
      startwith(fb:en.const) : 1
      startwith(fb:en.let) : 1
      startwith(fb:en.any) : 2
      fb:en.let : 1
      fb:en.const : 1
      fb:en.any : 2
      startwith(fb:en.num) : 1
=======================================================
Test on utterance 98:
  Line 0: I need to validate a range of x-y. 
    Top prediction: 
  Line 1: The numbers for x and y can't start with <M0>.
    Top prediction: fb:en.num
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.const : 1
  Line 2: The numbers for x and y can be 1 digit to 6 digits in length. 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 3
  Line 3: No other characters other than numbers and one <M1> between them allowed.
    Top prediction: not(fb:en.let)
    All 16 derivations and their counts: 
      fb:en.num : 1
      not(fb:en.const) : 1
      not(not(fb:en.any)) : 2
      and(not(fb:en.num),fb:en.const) : 1
      not(not(fb:en.let)) : 2
      not(fb:en.any) : 2
      not(fb:en.num) : 1
      not(and(fb:en.num,fb:en.const)) : 1
      fb:en.let : 1
      and(not(fb:en.num),repeat(fb:en.const,1)) : 1
      and(fb:en.num,repeat(fb:en.const,1)) : 1
      and(fb:en.num,fb:en.const) : 1
      not(and(fb:en.num,repeat(fb:en.const,1))) : 1
      fb:en.any : 1
      fb:en.const : 1
      not(fb:en.let) : 2
=======================================================
Test on utterance 99:
  Line 0: I need a regular expression that 
    Top prediction: 
  Line 1: has the following constraints:
    Top prediction: 
  Line 2: Contains only <M0> characters
    Top prediction: repeat(fb:en.let,1,)
    All 11 derivations and their counts: 
      repeat(fb:en.let,1,) : 1
      contain(repeat(fb:en.let,1,)) : 1
      contain(fb:en.any) : 1
      contain(repeat(fb:en.const,1,)) : 1
      contain(repeat(fb:en.any,1,)) : 1
      fb:en.let : 4
      fb:en.any : 4
      fb:en.const : 1
      contain(fb:en.let) : 1
      repeat(fb:en.any,1,) : 1
      contain(fb:en.const) : 1
  Line 3: Is 1 to 15 characters in length
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 1
  Line 4: Must contain a <M1> but only once.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 100:
  Line 0: The string must be 9 characters long,
    Top prediction: fb:en.any
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 2
  Line 1: starting with <M0> (case insensitive eg <M1>, <M2>, <M3> and <M4>) followed by 6 numbers.
    Top prediction: startwith(contain(fb:en.const))
    All 18 derivations and their counts: 
      startwith(contain(and(fb:en.const,fb:en.num))) : 1
      fb:en.num : 1
      startwith(fb:en.const) : 5
      and(fb:en.const,fb:en.const) : 1
      and(startwith(fb:en.const),fb:en.num) : 1
      startwith(and(contain(fb:en.const),fb:en.num)) : 1
      startwith(and(fb:en.const,fb:en.num)) : 1
      startwith(fb:en.num) : 1
      and(fb:en.const,fb:en.num) : 1
      and(startwith(contain(fb:en.const)),fb:en.const) : 1
      and(startwith(contain(fb:en.const)),fb:en.num) : 1
      startwith(contain(and(fb:en.const,fb:en.const))) : 1
      startwith(contain(fb:en.num)) : 1
      startwith(contain(fb:en.const)) : 5
      fb:en.const : 5
      startwith(and(fb:en.const,fb:en.const)) : 1
      startwith(and(contain(fb:en.const),fb:en.const)) : 1
      and(startwith(fb:en.const),fb:en.const) : 1
=======================================================
Test on utterance 101:
  Line 0: The first character should be a designated character like <M0>, <M1> or <M2> only. 
    Top prediction: fb:en.let
    All 4 derivations and their counts: 
      fb:en.let : 2
      fb:en.any : 2
      fb:en.const : 3
      or(fb:en.const,fb:en.const) : 1
  Line 1: and the next 3 characters should be numbers.
    Top prediction: fb:en.let
    All 3 derivations and their counts: 
      fb:en.num : 1
      fb:en.let : 1
      fb:en.any : 1
=======================================================
Test on utterance 102:
  Line 0: I have one field that 
    Top prediction: 
  Line 1: is meant to allow a 1 - 3 character string. 
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.let : 1
      fb:en.any : 2
  Line 2: The first character has got to be <M0>, <M1>, <M2> or <M3> and may optionally be followed by upto 2 characters.
    Top prediction: fb:en.let
    All 12 derivations and their counts: 
      and(fb:en.const,fb:en.let) : 1
      or(fb:en.const,fb:en.any) : 1
      and(fb:en.const,fb:en.any) : 1
      and(or(fb:en.const,fb:en.const),fb:en.any) : 1
      or(fb:en.const,and(fb:en.const,fb:en.any)) : 1
      or(fb:en.const,fb:en.let) : 1
      fb:en.let : 2
      fb:en.any : 2
      fb:en.const : 4
      or(fb:en.const,and(fb:en.const,fb:en.let)) : 1
      or(fb:en.const,fb:en.const) : 1
      and(or(fb:en.const,fb:en.const),fb:en.let) : 1
=======================================================
Test on utterance 103:
  Line 0: I am trying to implement regex validation for passport number. 
    Top prediction: fb:en.num
    All 1 derivations and their counts: 
      fb:en.num : 1
  Line 1: My requirement is
    Top prediction: 
  Line 2: Length should be minimum 3 characters to a maximum of 20 characters.
    Top prediction: repeat(fb:en.let,1)
    All 4 derivations and their counts: 
      repeat(fb:en.let,1) : 2
      repeat(fb:en.any,1) : 2
      fb:en.let : 2
      fb:en.any : 2
  Line 3: Should not be only <M0> 's
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
=======================================================
Test on utterance 104:
  Line 0: I have a field that 
    Top prediction: 
  Line 1: should accept:
    Top prediction: 
  Line 2: letters [a-zA-Z]
    Top prediction: fb:en.let
    All 1 derivations and their counts: 
      fb:en.let : 1
  Line 3: letters with numbers [a-zA-Z0-9]
    Top prediction: fb:en.let
    All 2 derivations and their counts: 
      fb:en.num : 1
      fb:en.let : 1
  Line 4: no special characters
    Top prediction: fb:en.let
    All 6 derivations and their counts: 
      fb:en.sp : 2
      not(fb:en.any) : 1
      fb:en.let : 3
      fb:en.any : 3
      not(fb:en.let) : 1
      not(fb:en.sp) : 1
=======================================================
Test on utterance 105:
  Line 0: Requirement:
    Top prediction: 
  Line 1: First part of the string can be; 
    Top prediction: repeat(fb:en.any,1)
    All 2 derivations and their counts: 
      repeat(fb:en.any,1) : 1
      fb:en.any : 1
  Line 2: Min 1 Max 6 char long. Upper case only.
    Top prediction: repeat(fb:en.cap,1,)
    All 2 derivations and their counts: 
      fb:en.cap : 1
      repeat(fb:en.cap,1,) : 1
  Line 3: Second part of the string can be; 
    Top prediction: repeat(fb:en.any,2)
    All 2 derivations and their counts: 
      repeat(fb:en.any,2) : 1
      fb:en.any : 1
  Line 4: Exactly 2 chars long but <M0> is not accepted.
    Top prediction: fb:en.const
    All 1 derivations and their counts: 
      fb:en.const : 1
  Line 5: So all together: 
    Top prediction: 
  Line 6: It can be min 3 max 8 chars long.
    Top prediction: 
=======================================================
=======================================================
=======================SUMMARY=========================
=======================================================
Total: 105
